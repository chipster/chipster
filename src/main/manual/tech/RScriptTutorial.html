<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><body>
<table id="toc" class="toc" summary="Contents"><tbody><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1"><a href="#R_script_integration_tutorial"><span class="tocnumber">1</span> <span class="toctext">R script integration tutorial</span></a>
<ul>
<li class="toclevel-2"><a href="#Working_in_command_line"><span class="tocnumber">1.1</span> <span class="toctext">Working in command line</span></a></li>
<li class="toclevel-2"><a href="#Adding_and_removing_tools"><span class="tocnumber">1.2</span> <span class="toctext">Adding and removing tools</span></a></li>
<li class="toclevel-2"><a href="#Creating_manual_pages"><span class="tocnumber">1.3</span> <span class="toctext">Creating manual pages</span></a></li>
<li class="toclevel-2"><a href="#Calling_external_applications_from_R"><span class="tocnumber">1.4</span> <span class="toctext">Calling external applications from R</span></a></li>
<li class="toclevel-2"><a href="#Other_ways_to_update_scripts"><span class="tocnumber">1.5</span> <span class="toctext">Other ways to update scripts</span></a></li>
</ul>
</li>
</ul>
<a name="R_script_integration_tutorial" id="R_script_integration_tutorial"></a><h2> R script integration tutorial </span></h2>
<p>This tutorial will show how to modify or add new analysis tool to a 
Chipster server. Integrating analysis tools is a straightforward 
process, allowing you to use Chipster as a medium for serving and 
supporting large number of users not experienced in data analysis and 
programming. Here we focus on tools written using the R programming 
language, but the process is pretty much the same also with other 
flavours of analysis tools.
</p><p>To be able to work with tool scripts you need to be able to log 
into the Chipster server. This is an important restriction to guarantee 
security of the server: analysis tools are essentially unrestricted 
pieces of code that will be run on the server, meaning that the ability 
to add or modify tools is equal to the ability to log into the system. 
</p><p>In practice, developing R scripts for Chipster means editing files on the <i>comp/modules</i>
 subdirectory of the Chipster installation inside the server. This can 
be done either by logging into the Linux command line and running the 
file editor there, or connecting the server filesystem and editing the 
files using the file editor you normally use. Let's first have a look at
 the command line option, as you always need the command line for some 
server administration tasks anyway.
</p><p><br>
</p>
<a name="Working_in_command_line" id="Working_in_command_line"></a><h3> <span class="mw-headline"> Working in command line </span></h3>
<p>Once you have started a fresh Chipster server using the virtual 
machine images that are provided, you need to login there for the first 
time. To do this, you typically use the virtual console of your 
virtualisation software (e.g. VirtualBox or VMware). This virtual 
console corresponds to a physical console (display and keyboard) of a 
real server machine. It opens up when you start the virtual machine.
</p><p>Login using the username "chipster". If you haven't already changed the password, then it is "chipster" by default.
</p><p>Now you are at the console command line. Virtual consoles are not
 very user friendly, so it is recommended to use SSH to connect to the 
server. When you logged in, you were provided with a "message of the 
day" that contains some useful bits of information, including the IP 
address of the virtual server. Record the IP address and log out.
</p><p>Next open up your favourite SSH client and point it to the IP 
address of the server. Login using the "chipster" account again. Switch 
into directory that contains analysis tool modules and list them.
</p>
<pre>cd /opt/chipster/comp/modules/
ls
</pre>
<p>There you can see the analysis modules, typically <b>common</b>, <b>microarray</b> and <b>ngs</b>. Module <b>common</b> contains utility functions that can be used by the actual tool scripts in the other modules.
</p><p>Each module has a configuration file that describes the tools inside the module. 
</p>
<pre>cat microarray/microarray-module.xml
</pre>
<p>Typically you would edit the file to add or remove tools and tool categories.
</p><p>Next we switch to a directory that contains the actual analysis scripts and have a look at there.
</p>
<pre>cd microarray/R-2.12
ls
</pre>
<p>You can see a large number of scripts, each of them corresponding to a
 single tool you have on the client GUI. To make things as simple as 
possible, Chipster has a one-to-one mapping between tools and files. To 
create a tool, you need to create only a single file. And a single file 
is related to a single tool. If you need to share functionality between 
tools, the <b>common</b> module is available for that.
</p><p>To modify a tool, you can just edit it with a text editor:
</p>
<pre>nano na-omitted.R
</pre>
<p>The tool should look like the following:
</p>
<pre># TOOL na-omitted.R: "Remove missing values" (Removal of missing values. All observations, i.e., genes that have at least one missing value are excluded from the data set.)
# INPUT normalized.tsv: normalized.tsv TYPE GENE_EXPRS 
# OUTPUT na-omitted.tsv: na-omitted.tsv 

# Removal of missing values
# JTT 22.6.2006

# Loads the file
file&lt;-c("normalized.tsv")
dat&lt;-read.table(file, header=T, sep="\t", row.names=1)

# Removes missing values
dat&lt;-na.omit(dat)

# Writes a table 
write.table(dat, file=("na-omitted.tsv"), sep="\t", row.names=T, col.names=T, quote=F)
</pre>
<p>As you can see, there are two parts in the script. First there are 3 
lines of header, which describes the tool for Chipster. After the header
 you have the script itself, just a regular script of R commands. The 
header is commented so that the description snippet can be conveniently 
part of the executable R script file. It is written using simple and 
compact description language called SADL. The most practical way to get 
started with SADL descriptions is to have a look at similar tools and 
their headers. For complete reference, look at:
</p><p><a href="TechnicalManual.html#Describing_tools_with_SADL">TechnicalManual: Describing tools with SADL</a>
</p><p>Next we work with the script a bit. Changes to tool scripts are 
visible immediately. You can try this out by adding this to the end of 
the script (and saving it):
</p>
<pre># I was here!
</pre>
<p>When you open the Chipster client and click Show sourcecode for 
Remove missing values tool, you should see your additional line there. 
If you remove the line, save and hit Show sourcecode again, you will see
 that the line has disappeared. It is important to remember that if you 
change the header part of the script, then you need to restart your 
client so that it can recreate its internal data structures and GUI 
components to match the updated tool.
</p><p><br>
</p>
<a name="Adding_and_removing_tools" id="Adding_and_removing_tools"></a><h3> <span class="mw-headline"> Adding and removing tools </span></h3>
<p>To add or remove a tool, edit the corresponding module configuration file, e.g.:
</p>
<pre>cd /opt/chipster/comp/modules/microarray/
nano microarray-module.xml
</pre>
<p>Tool can be removed by simply removing or commenting out the XML 
entry from the file. To add a tool, create a new entry. As an example, 
consider this snippet from <b>microarray-module.xml</b>:
</p>
<pre>&lt;tool runtime="R-2.12"&gt;&lt;resource&gt;filter-expression.R&lt;/resource&gt;&lt;/tool&gt;
&lt;tool runtime="R-2.12"&gt;&lt;resource&gt;filter-flags.R&lt;/resource&gt;&lt;/tool&gt;
&lt;tool runtime="R-2.12"&gt;&lt;resource&gt;filter-sd.R&lt;/resource&gt;&lt;/tool&gt;
</pre>
<p>To remove flag filtering and add p-value filtering, you would change the snippet to following:
</p>
<pre>&lt;tool runtime="R-2.12"&gt;&lt;resource&gt;filter-expression.R&lt;/resource&gt;&lt;/tool&gt;
&lt;tool runtime="R-2.12"&gt;&lt;resource&gt;filter-sd.R&lt;/resource&gt;&lt;/tool&gt;
&lt;tool runtime="R-2.12"&gt;&lt;resource&gt;filter-pvalue.R&lt;/resource&gt;&lt;/tool&gt;
</pre>
<p>The <b>runtime</b> attribute defines the runtime environment to use when running the tool. They are specified in <i>comp/config/runtimes.xml</i>.
 For R scripts, you need to pick the correct version of the R 
environment for your script (in these examples, it is R 2.12). As we 
have seen, scripts are stored in runtime specific subdirectories of the 
module. It means that tools can have different versions for different 
runtimes, allowing to cater for e.g. differences between R syntax. 
Mostly this functionality is used when a set of scripts is gradually 
updated to a later R version.
</p>
<a name="Creating_manual_pages" id="Creating_manual_pages"></a><h3> <span class="mw-headline"> Creating manual pages </span></h3>
<p>The client has a More help button associated with each tool. It takes
 user to a tool specific manual page, assuming the page exists. Manual 
is hosted in the server, and more particularly, on the <b>webstart</b> component that also serves the startup page. In the server, switch to <b>manual</b> directory and check it:
</p>
<pre>cd /opt/chipster/webstart/web-root/manual
ls
</pre>
<p>You can see a long list of HTML pages. Their names match tool names, 
but manual pages are not organised into module and runtime hierarchies.
</p><p>To create a manual page for a tool saved in foobar.R, create a 
file called foobar.html and fill it in by e.g. using this template:
</p>
<pre>&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;
&lt;html lang="en"&gt;
&lt;head&gt;&lt;title&gt;Fill in tool name here&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;h2&gt;Fill in tool name here&lt;/h2&gt;
&lt;h3&gt;Description&lt;/h3&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;h3&gt;Parameters&lt;/h3&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;h3&gt;Details&lt;/h3&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;h3&gt;Output&lt;/h3&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;/body&gt;
</pre>
<p>Manual pages are shown in user's default system browser, which means that rich variety of HTML tricks can be used.
</p>
<a name="Calling_external_applications_from_R" id="Calling_external_applications_from_R"></a><h3> <span class="mw-headline">  Calling external applications from R </span></h3>
<p>When calling external applications, you need to take care of checking
 that everything went fine. To report possible problems, you can use the
 CHIPSTER-NOTE functionality.
</p><p>To get out the return code from a command line call, use:
</p>
<pre>command &lt;- "ls"
ret &lt;- system(command)
</pre>
<p>Next check the return code. If it is not equal to zero, use CHIPSTER-NOTE to fail and report a nice error message to user.
</p>
<pre>if (ret&nbsp;!= 0) { 
  stop("CHIPSTER-NOTE: It failed, because...")
}
</pre>
<p>When this functionality is used, Chipster will not show R screen dump
 to the user, but instead display a friendlier dialog that shows the 
error message supplied by you. A good design principle for tools is that
 they should never fail unexpectedly, but instead all possible error 
sources (wrong parameters, faulty data) should be checked and reported 
nicely.
</p><p><br>
</p>
<a name="Other_ways_to_update_scripts" id="Other_ways_to_update_scripts"></a><h3> <span class="mw-headline"> Other ways to update scripts </span></h3>
<p>Tool development in Chipster means editing R files and other script 
files, and occassionally touching the XML module descriptions. So far we
 have been doing this by logging into the server and running text 
editors on the command line. However that is somewhat clumsy and it is 
recommended to set up a more streamlined development environment.
</p><p><b>Use file explorer via SFTP to edit files.</b> This is often 
the easiest solution, depending on your operating system. The idea is to
 use SFTP (SSH file transfer protocol) to browse the server, just like 
you would browse files on your own workstation. For instructions see <a href="SSHMountTutorial.html" >SSHMountTutorial</a>.
</p><p><b>Create a shared drive between workstation (host) and server.</b>
 Virtualisation softwares support disk/directory sharing between the 
virtual machine and host machine. This is somewhat similar to using SFTP
 to mount or semi-mount the virtual machine contents, but is often a bit
 more work to set up. In VirtualBox, you need to install Guest Additions
 package to the Ubuntu Linux that is running in the virtual machine. 
After that disk share can be created with Settings -&gt; Shared Folders 
-&gt; Add (enable "Auto mount"), when the server is not running. In 
other virtualisation softwares the process is similar. Please consult 
the documentation of your virtualisation software for more information.
</p><p><b>Deploy from workstation.</b> You can also copy the <b>modules</b>
 directory to your workstation and set up scripts to deploy changes e.g.
 use scp or rsync to copy the scripts from your workstation to the 
server. You can also import the files into a version control system, 
which is recommended when developing tool script code. Of course it is 
also possible to checkout the <b>modules</b> directory from version control directly in the server.
</p>
</body></html>